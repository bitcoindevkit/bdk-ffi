namespace bdk {};

// ------------------------------------------------------------------------
// bdk crate - error module
// ------------------------------------------------------------------------

[Error]
interface AddressParseError {
  Base58();
  Bech32();
  WitnessVersion(string error_message);
  WitnessProgram(string error_message);
  UnknownHrp();
  LegacyAddressTooLong();
  InvalidBase58PayloadLength();
  InvalidLegacyPrefix();
  NetworkValidation();
  OtherAddressParseErr();
};

[Error]
interface Bip32Error {
    CannotDeriveFromHardenedKey();
    Secp256k1(string error_message);
    InvalidChildNumber(u32 child_number);
    InvalidChildNumberFormat();
    InvalidDerivationPathFormat();
    UnknownVersion(string version);
    WrongExtendedKeyLength(u32 length);
    Base58(string error_message);
    Hex(string error_message);
    InvalidPublicKeyHexLength(u32 length);
    UnknownError(string error_message);
};

[Error]
interface Bip39Error {
  BadWordCount(u64 word_count);
  UnknownWord(u64 index);
  BadEntropyBitCount(u64 bit_count);
  InvalidChecksum();
  AmbiguousLanguages(string languages);
};

[Error]
interface CreateTxError {
  Descriptor(string error_message);
  Policy(string error_message);
  SpendingPolicyRequired(string kind);
  Version0();
  Version1Csv();
  LockTime(string requested, string required);
  RbfSequenceCsv(string sequence, string csv);
  FeeTooLow(string required);
  FeeRateTooLow(string required);
  NoUtxosSelected();
  OutputBelowDustLimit(u64 index);
  ChangePolicyDescriptor();
  CoinSelection(string error_message);
  InsufficientFunds(u64 needed, u64 available);
  NoRecipients();
  Psbt(string error_message);
  MissingKeyOrigin(string key);
  UnknownUtxo(string outpoint);
  MissingNonWitnessUtxo(string outpoint);
  MiniscriptPsbt(string error_message);
  PushBytesError();
  LockTimeConversionError();
};

[Error]
interface DescriptorError {
    InvalidHdKeyPath();
    InvalidDescriptorChecksum();
    HardenedDerivationXpub();
    MultiPath();
    Key(string error_message);
    Policy(string error_message);
    InvalidDescriptorCharacter(string char);
    Bip32(string error_message);
    Base58(string error_message);
    Pk(string error_message);
    Miniscript(string error_message);
    Hex(string error_message);
    ExternalAndInternalAreTheSame();
};

[Error]
interface DescriptorKeyError {
  Parse(string error_message);
  InvalidKeyType();
  Bip32(string error_message);
};

[Error]
interface ElectrumError {
  IOError(string error_message);
  Json(string error_message);
  Hex(string error_message);
  Protocol(string error_message);
  Bitcoin(string error_message);
  AlreadySubscribed();
  NotSubscribed();
  InvalidResponse(string error_message);
  Message(string error_message);
  InvalidDNSNameError(string domain);
  MissingDomain();
  AllAttemptsErrored();
  SharedIOError(string error_message);
  CouldntLockReader();
  Mpsc();
  CouldNotCreateConnection(string error_message);
  RequestAlreadyConsumed();
};

[Error]
interface EsploraError {
  Minreq(string error_message);
  HttpResponse(u16 status, string error_message);
  Parsing(string error_message);
  StatusCode(string error_message);
  BitcoinEncoding(string error_message);
  HexToArray(string error_message);
  HexToBytes(string error_message);
  TransactionNotFound();
  HeaderHeightNotFound(u32 height);
  HeaderHashNotFound();
  InvalidHttpHeaderName(string name);
  InvalidHttpHeaderValue(string value);
  RequestAlreadyConsumed();
  InvalidResponse();
};

[Error]
interface FeeRateError {
  ArithmeticOverflow();
};

[Error]
interface FromScriptError {
  UnrecognizedScript();
  WitnessProgram(string error_message);
  WitnessVersion(string error_message);
  OtherFromScriptErr();
};

[Error]
interface MiniscriptError {
    AbsoluteLockTime();
    AddrError(string error_message);
    AddrP2shError(string error_message);
    AnalysisError(string error_message);
    AtOutsideOr();
    BadDescriptor(string error_message);
    BareDescriptorAddr();
    CmsTooManyKeys(u32 keys);
    ContextError(string error_message);
    CouldNotSatisfy();
    ExpectedChar(string char);
    ImpossibleSatisfaction();
    InvalidOpcode();
    InvalidPush();
    LiftError(string error_message);
    MaxRecursiveDepthExceeded();
    MissingSig();
    MultiATooManyKeys(u64 keys);
    MultiColon();
    MultipathDescLenMismatch();
    NonMinimalVerify(string error_message);
    NonStandardBareScript();
    NonTopLevel(string error_message);
    ParseThreshold();
    PolicyError(string error_message);
    PubKeyCtxError();
    RelativeLockTime();
    Script(string error_message);
    Secp(string error_message);
    Threshold();
    TrNoScriptCode();
    Trailing(string error_message);
    TypeCheck(string error_message);
    Unexpected(string error_message);
    UnexpectedStart();
    UnknownWrapper(string char);
    Unprintable(u8 byte);
};

[Error]
interface ParseAmountError {
  OutOfRange();
  TooPrecise();
  MissingDigits();
  InputTooLarge();
  InvalidCharacter(string error_message);
  OtherParseAmountErr();
};

[Error]
interface PersistenceError {
  Write(string error_message);
};

[Error]
interface PsbtError {
  InvalidMagic();
  MissingUtxo();
  InvalidSeparator();
  PsbtUtxoOutOfBounds();
  InvalidKey(string key);
  InvalidProprietaryKey();
  DuplicateKey(string key);
  UnsignedTxHasScriptSigs();
  UnsignedTxHasScriptWitnesses();
  MustHaveUnsignedTx();
  NoMorePairs();
  UnexpectedUnsignedTx();
  NonStandardSighashType(u32 sighash);
  InvalidHash(string hash);
  InvalidPreimageHashPair();
  CombineInconsistentKeySources(string xpub);
  ConsensusEncoding(string encoding_error);
  NegativeFee();
  FeeOverflow();
  InvalidPublicKey(string error_message);
  InvalidSecp256k1PublicKey(string secp256k1_error);
  InvalidXOnlyPublicKey();
  InvalidEcdsaSignature(string error_message);
  InvalidTaprootSignature(string error_message);
  InvalidControlBlock();
  InvalidLeafVersion();
  Taproot();
  TapTree(string error_message);
  XPubKey();
  Version(string error_message);
  PartialDataConsumption();
  Io(string error_message);
  OtherPsbtErr();
};

[Error]
interface PsbtParseError {
  PsbtEncoding(string error_message);
  Base64Encoding(string error_message);
};

[Error]
interface PsbtFinalizeError {
  InputError(string reason, u32 index);
  WrongInputCount(u32 in_tx, u32 in_map);
  InputIdxOutofBounds(u32 psbt_inp, u32 requested);
};

[Error]
interface RequestBuilderError {
  RequestAlreadyConsumed();
};

[Error]
interface TransactionError {
  Io();
  OversizedVectorAllocation();
  InvalidChecksum(string expected, string actual);
  NonMinimalVarInt();
  ParseFailed();
  UnsupportedSegwitFlag(u8 flag);
  OtherTransactionErr();
};

// ------------------------------------------------------------------------
// bdk_wallet crate - types module
// ------------------------------------------------------------------------

typedef enum KeychainKind;

/// An unspent output owned by a [`Wallet`].
dictionary LocalOutput {
  /// Reference to a transaction output
  OutPoint outpoint;

  /// Transaction output
  TxOut txout;

  /// Type of keychain
  KeychainKind keychain;

  /// Whether this UTXO is spent or not
  boolean is_spent;

  /// The derivation index for the script pubkey in the wallet
  u32 derivation_index;

  /// The position of the output in the blockchain.
  ChainPosition chain_position;
};

typedef dictionary TxOut;

typedef enum ChainPosition;

typedef dictionary CanonicalTx;

/// Builds a [`FullScanRequest`].
interface FullScanRequestBuilder {
  [Throws=RequestBuilderError]
  FullScanRequestBuilder inspect_spks_for_all_keychains(FullScanScriptInspector inspector);

  [Throws=RequestBuilderError]
  FullScanRequest build();
};

/// Builds a [`SyncRequest`].
interface SyncRequestBuilder {
  [Throws=RequestBuilderError]
  SyncRequestBuilder inspect_spks(SyncScriptInspector inspector);

  [Throws=RequestBuilderError]
  SyncRequest build();
};

interface FullScanRequest {};

interface SyncRequest {};

[Trait, WithForeign]
interface SyncScriptInspector {
  void inspect(Script script, u64 total);
};

[Trait, WithForeign]
interface FullScanScriptInspector {
  void inspect(KeychainKind keychain, u32 index, Script script);
};

/// A changeset for [`Wallet`].
[Remote]
interface ChangeSet {};

/// Options for a software signer.
///
/// Adjust the behavior of our software signers and the way a transaction is finalized.
dictionary SignOptions {
    /// Whether the signer should trust the `witness_utxo`, if the `non_witness_utxo` hasn't been
    /// provided
    ///
    /// Defaults to `false` to mitigate the "SegWit bug" which could trick the wallet into
    /// paying a fee larger than expected.
    ///
    /// Some wallets, especially if relatively old, might not provide the `non_witness_utxo` for
    /// SegWit transactions in the PSBT they generate: in those cases setting this to `true`
    /// should correctly produce a signature, at the expense of an increased trust in the creator
    /// of the PSBT.
    ///
    /// For more details see: <https://blog.trezor.io/details-of-firmware-updates-for-trezor-one-version-1-9-1-and-trezor-model-t-version-2-3-1-1eba8f60f2dd>
    boolean trust_witness_utxo;

    /// Whether the wallet should assume a specific height has been reached when trying to finalize
    /// a transaction
    ///
    /// The wallet will only "use" a timelock to satisfy the spending policy of an input if the
    /// timelock height has already been reached. This option allows overriding the "current height" to let the
    /// wallet use timelocks in the future to spend a coin.
    u32? assume_height;

    /// Whether the signer should use the `sighash_type` set in the PSBT when signing, no matter
    /// what its value is
    ///
    /// Defaults to `false` which will only allow signing using `SIGHASH_ALL`.
    boolean allow_all_sighashes;

    /// Whether to try finalizing the PSBT after the inputs are signed.
    ///
    /// Defaults to `true` which will try finalizing PSBT after inputs are signed.
    boolean try_finalize;

    /// Whether we should try to sign a taproot transaction with the taproot internal key
    /// or not. This option is ignored if we're signing a non-taproot PSBT.
    ///
    /// Defaults to `true`, i.e., we always try to sign with the taproot internal key.
    boolean sign_with_tap_internal_key;

    /// Whether we should grind ECDSA signature to ensure signing with low r
    /// or not.
    /// Defaults to `true`, i.e., we always grind ECDSA signature to sign with low r.
    boolean allow_grinding;
};

// ------------------------------------------------------------------------
// bdk_wallet crate - wallet module
// ------------------------------------------------------------------------

interface Policy {
  string id();
  
  string as_string();

  boolean requires_path();
  
  SatisfiableItem item();
  
  Satisfaction satisfaction();

  Satisfaction contribution();
};

[Enum]
interface SatisfiableItem {
  EcdsaSignature(PkOrF key);
  SchnorrSignature(PkOrF key);
  Sha256Preimage(string hash);
  Hash256Preimage(string hash);
  Ripemd160Preimage(string hash);
  Hash160Preimage(string hash);
  AbsoluteTimelock(LockTime value);
  RelativeTimelock(u32 value);
  Multisig(sequence<PkOrF> keys, u64 threshold);
  Thresh(sequence<Policy> items, u64 threshold);
};

[Enum]
interface PkOrF {
  Pubkey(string value);
  XOnlyPubkey(string value);
  Fingerprint(string value);
};

[Enum]
interface LockTime {
  Blocks(u32 height);
  Seconds(u32 consensus_time);
};

[Enum]
interface Satisfaction {
    Partial(u64 n, u64 m, sequence<u64> items, boolean? sorted, record<u32, sequence<Condition>> conditions);
    PartialComplete(u64 n, u64 m, sequence<u64> items, boolean? sorted, record<sequence<u32>, sequence<Condition>> conditions);
    Complete(Condition condition);
    None(string msg);
};

dictionary Condition {
  u32? csv;
  LockTime? timelock;
};

// ------------------------------------------------------------------------
// bdk crate - descriptor module
// ------------------------------------------------------------------------

[Traits=(Display)]
interface Mnemonic {
  constructor(WordCount word_count);

  [Name=from_string, Throws=Bip39Error]
  constructor(string mnemonic);

  [Name=from_entropy, Throws=Bip39Error]
  constructor(sequence<u8> entropy);
};

interface DerivationPath {
  [Throws=Bip32Error]
  constructor(string path);
};

interface DescriptorSecretKey {
  constructor(Network network, [ByRef] Mnemonic mnemonic, string? password);

  [Name=from_string, Throws=DescriptorKeyError]
  constructor(string secret_key);

  [Throws=DescriptorKeyError]
  DescriptorSecretKey derive([ByRef] DerivationPath path);

  [Throws=DescriptorKeyError]
  DescriptorSecretKey extend([ByRef] DerivationPath path);

  DescriptorPublicKey as_public();

  sequence<u8> secret_bytes();

  string as_string();
};

interface DescriptorPublicKey {
  [Name=from_string, Throws=DescriptorKeyError]
  constructor(string public_key);

  [Throws=DescriptorKeyError]
  DescriptorPublicKey derive([ByRef] DerivationPath path);

  [Throws=DescriptorKeyError]
  DescriptorPublicKey extend([ByRef] DerivationPath path);

  string as_string();

  /// Whether or not this key has multiple derivation paths.
  boolean is_multipath();

  /// The fingerprint of the master key associated with this key, `0x00000000` if none.
  string master_fingerprint();
};

[Traits=(Display)]
interface Descriptor {
  [Throws=DescriptorError]
  constructor(string descriptor, Network network);

  [Name=new_bip44]
  constructor([ByRef] DescriptorSecretKey secret_key, KeychainKind keychain, Network network);

  [Name=new_bip44_public]
  constructor([ByRef] DescriptorPublicKey public_key, string fingerprint, KeychainKind keychain, Network network);

  [Name=new_bip49]
  constructor([ByRef] DescriptorSecretKey secret_key, KeychainKind keychain, Network network);

  [Name=new_bip49_public]
  constructor([ByRef] DescriptorPublicKey public_key, string fingerprint, KeychainKind keychain, Network network);

  [Name=new_bip84]
  constructor([ByRef] DescriptorSecretKey secret_key, KeychainKind keychain, Network network);

  [Name=new_bip84_public]
  constructor([ByRef] DescriptorPublicKey public_key, string fingerprint, KeychainKind keychain, Network network);

  [Name=new_bip86]
  constructor([ByRef] DescriptorSecretKey secret_key, KeychainKind keychain, Network network);

  [Name=new_bip86_public]
  constructor([ByRef] DescriptorPublicKey public_key, string fingerprint, KeychainKind keychain, Network network);

  string to_string_with_secret();

  /// Get a xPub from the descriptor
  string to_x_pub();

  /// Whether or not this key has multiple derivation paths.
  boolean is_multipath();

  /// Get as many descriptors as different paths in this descriptor.
  ///
  /// For multipath descriptors it will return as many descriptors as there is
  /// "parallel" paths. For regular descriptors it will just return itself.
  [Throws=MiniscriptError]
  sequence<Descriptor> to_single_descriptors();
};

// ------------------------------------------------------------------------
// bdk-ffi-defined types
// ------------------------------------------------------------------------

typedef dictionary TxStatus;

dictionary Tx {
    string txid;
    i32 version;
    u32 locktime;
    u64 size;
    u64 weight;
    u64 fee;
    TxStatus status;
};

// ------------------------------------------------------------------------
// bdk_wallet crate - bitcoin re-exports
// ------------------------------------------------------------------------

[Remote]
enum WordCount {
  "Words12",
  "Words15",
  "Words18",
  "Words21",
  "Words24",
};

typedef interface Address;

typedef dictionary Header;

typedef interface Psbt;

dictionary TxIn {
  OutPoint previous_output;
  Script script_sig;
  u32 sequence;
  sequence<sequence<u8>> witness;
};

typedef interface Script;

[NonExhaustive, Remote]
enum Network {
  "Bitcoin",
  "Testnet",
  "Signet",
  "Regtest",
  "Testnet4",
};

typedef interface FeeRate;

dictionary OutPoint {
  string txid;
  u32 vout;
};
